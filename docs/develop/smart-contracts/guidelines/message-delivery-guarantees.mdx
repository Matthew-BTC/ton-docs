import ConceptImage from '@site/src/components/conceptImage';

# Message Delivery Guarantees

TON is an asynchronous blockchain with a complex structure very different from other blockchains. Because of this, new developers often have questions about the low-level technicalities of TON. In this article, we will have a look at one of these related to message delivery.

## What is a message?

Looking at Ethereum or almost any other synchronous blockchain, each transaction can contain several smart contract calls. For example, DEXs perform multiple exchanges in one transaction if there is no liquidity for the selected trading pair.

In an asynchronous system, you can't get a response from the destination smart contract in the same transaction. A contract call may take a few blocks to be processed, depending on the route length between source and destination.

It is necessary to ensure full parallelization, which means that the execution of each transaction is independent of every other, to achieve the infinite sharding paradigm. Therefore, instead of transactions that affect and change the state of many contracts simultaneously, each transaction on TON is only executed on a single smart contract, and smart contracts communicate through messages. That way, smart contracts can only interact by calling their functions with special messages and getting a response to them via other messages later.

If a transaction in Ethereum is just a set of function calls in different contracts, a transaction in TON comprises the inbound message that initially triggered it and a set of outbound messages sent to other contracts.

## What is Logical Time?

Defining the order of actions to process in such a system with asynchronous and parallel smart contract calls can be challenging. That's why each message on TON has its _Logical time_ or _Lamport time_ (later just _lt_). It is used to understand which event caused another and what a validator needs to process first.

It is strictly guaranteed that the transaction resulting from a message will have a _lt_ greater than the _lt_ of the message. Likewise, the _lt_ of a message sent in some transaction is strictly greater than the _lt_ of the transaction that caused it. Messages sent from one account and transactions on one account are also strictly ordered. Thanks to this, we always know the order of transactions, received and sent messages for every account.

Moreover, if account _A_ sends two messages to account _B_, it is guaranteed that the message with a lower _lt_ will be processed earlier. Otherwise, an attempt to synchronize delivery would require the state of all the others to be known before processing one shard, thereby breaking parallelization and destroying efficient sharding.

For each block, we can define the _lt_ span as starting from the first transaction and ending with the _lt_ of the last event in the block (message or transaction). Blocks are ordered the same way as other events on TON, so if one block depends on the other, it has a higher _lt_. The child block in a shard has a higher _lt_ than its parent. A masterchain block's _lt_ is higher than the _lts_ of shard blocks that it lists since a master block depends on listed shard blocks. Each shard block contains an ordered reference to the latest (at the moment of shard block creation) master block, and thus, the shard block _lt_ is higher than the referenced master block _lt_.

## Message delivery

TON works so that the destination account will receive any internal message. A message cannot be lost between the source and its destination. External messages are slightly different since their acceptance to the block is at the validator's discretion; however, once the message is accepted into the incoming message queue, it will be delivered.

### Delivery order

It seems that _lt_ solves the issue about message delivery order because we know that a transaction with a lower _lt_ will be processed first. But this doesn't work in every scenario.

Suppose there are two contracts - _A_ and _B_. _A_ receives an external message, which triggers it to send two internal messages to _B_. Let's call these messages _1_ and _2_. In this simple case, we can be 100% sure that _1_ will be processed by _B_ before _2_ because it has a lower _lt_.

<ConceptImage src="/img/docs/msg-delivery-1.png" />

But this is just a simple case when we only have two contracts. How does our system work in more complex cases?

### Several smart contracts

Suppose we have three contracts - _A_, _B_, and _C_. In a transaction, _A_ sends two internal messages, _1_ and _2_: one to _B_ and another to _C_. Even though they were created in an exact order (_1_, then _2_), we can't be sure that _1_ will be processed before _2_. This is because routes from _A_ to _B_ and from _A_ to _C_ can differ in length and validator sets. If these contracts are in different shardchains, one of the messages may require several blocks to reach the destination contract.

<ConceptImage src="/img/docs/msg-delivery-2.png" />

The same happens in the reverse case, when two contracts, _B_ and _C_, send a message to one contract, _A_. Even if message `B -> A` was sent before `C -> A,` we can't know which one will be delivered first. The `B -> A` route may require more shard chain hops.

<ConceptImage src="/img/docs/msg-delivery-3.png" />

There can be many scenarios of smart contract interactions, and in any scenario with more than two contracts, the order of message delivery may be arbitrary. The only guarantee is that messages from any contract _A_ to any contract _B_ will be processed in order of their logical time. Below are some examples.

<ConceptImage src="/img/docs/msg-delivery-4.png" />
<ConceptImage src="/img/docs/msg-delivery-5.png" />
<ConceptImage src="/img/docs/msg-delivery-6.png" />

## Conclusion

TON Blockchain's asynchronous structure creates challenges for message delivery guarantees. Logical time helps to establish event and transaction order but doesn't guarantee message delivery order between multiple smart contracts due to varying routes in shardchains. Despite these complexities, TON ensures internal message delivery, maintaining network reliability. Developers must adapt to these nuances to harness TON's full potential in building innovative decentralized applications.
